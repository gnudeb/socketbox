##### Лабораторна робота 3
## Багатопотоковий сервер

### Зміст
* [Вступ](#вступ)
* [Багатопоточність](#багатопоточність)
* [Індивідуальні завдання](#індивідуальні-завдання)

### Вступ

У попередніх лабораторних роботах ми використовували
сервер, у якого є один недолік -- він обробляє
клієнтів у одному потоці. Наслідок цього такий --
до сервера одночасто може під'єднатися лише один
клієнт. Іншому клієнтові доведеться чекати, поки
сервер розірве зв'язок з першим.

Вихід з цього становища -- обробка клієнтів в окремих
потоках виконання.

### Telnet

Для тестування TCP-серверів зручно використовувати
консольну програму під назвою `telnet`, що є у
будь-якій операційній системі. Наприклад, щоб
під'єднатися до локального сервера до порту 1898,
треба ввести наступну команду:

```bash
$ telnet localhost 1898
```

Програма сповістить про вдале (або невдале) з'єднання,
і після цього будь-який текст, який ви напишете у
консолі, буде надісланий до сервера за протоколом
TCP, а відповіді сервера відображатимуться після
запитів.

Для перевірки можливості обробки декількох клієтнів
необхідно просто спробувати під'єднатися до сервера
з двох клієнтів `telnet` одночасно. У випадку з нашим
сервером, другий клієнт чекатиме, поки сервер
закриє з'єднання з першим.

### Багатопоточність

Стандартні засоби мови Python дозволяють виконувати
будь-які функції у окремих потоках. Для прикладу
напишемо функцію, яка за одну секунду після виклику
виводить у консоль слово `Tick!`:

```python
from time import sleep

def tick():
    sleep(1)
    print("Tick!")
```

Якщо таку функцію викликати у циклі, кожне виконання
займатиме одну секунду:

```python
>>> for _ in range(5):
...     tick()
Tick!
Tick!
Tick!
Tick!
Tick!
```

З іншого боку, можна функцію запустити у п'яти
потоках:

```python
>>> from threading import Thread
>>> for _ in range(5):
...     Thread(target=tick).start()
Tick!
Tick!
Tick!
Tick!
Tick!
```

В такому випадку усі п'ять потоків одночасно виведуть
слово `Tick!`, оскільки усі потоки виконуються
паралельно.

### Багатопоточність у сервері

Згадайте, як виглядав обробник з'єднань сервера у
першій лабораторній роботі:

```python
while True:
    client_socket, address = s.accept()
    client_socket.send(b"Hello, World!\r\n")
    client_socket.close()
```

Такий обробник не зможе прийняти нове з'єднання, поки
не закінчить роботу з поточним. Для обробки багатьох
клієнтів одночасно можна запускати обробник окремо
для кожного з'єднання:

```python
def handle_connection(client_socket: socket):
    client_socket.send(b"Hello, World!\r\n")
    client_socket.close()

while True:
    client_socket, address = s.accept()
    client_thread = Thread(target=handle_connection, args=(client_socket,))
    client_thread.start()
```

Тут, приймаючи нове з'єднання, ми створюємо новий
потік, в якому буде працювати обробник
`handle_connection`, і обробляти клієнтський сокет
`client_socket`.

Таким чином, головний потік лише приймає нове
з'єднання та запускає обробник для нього в
окремему потоці, що дозволяє серверу працювати з
багатьма клієнтами одночасно.

### Індивідуальні завдання
