##### Лабораторна робота 2
## Повідомленнєво-орієнтований протокол

### Зміст
* [Вступ](#вступ)

### Вступ

У попередній лабораторній роботі було зазначено, що
TCP -- це протокол *потокової* передачі даних.
Незважаючи на те, що цей протокол розбиває потік на
окремі пакети, ці пакети не можна розцінювати як
окремі повідомлення. Це є наслідком того факту, що
сторона-відправник може розбивати вихідний потік
даних як заманеться.

### Оманлива поведінка функцій `send` та `recv`

При роботі з TCP дуже легко зробити припущення про
те, що один виклик відправником функції `send`
відповідає одному виклику приймачем функції `recv`.
Справді, якщо відправник надсилатиме повідомлення
кожну секунду, то результат буде очевидним.

```python
from socket import socket
from time import sleep


server_socket = socket()
host = "localhost"
port = 1898
server_socket.bind((host, port))
server_socket.listen(5)

client_socket = socket()
client_socket.connect((host, port))


new_client, address = server_socket.accept()

for i in range(10):
    new_client.send(b"Hello!\r\n")
    sleep(1)
    print(client_socket.recv(4096))

new_client.close()
server_socket.close()
```

Ця програма створює локальний сервер, який десять
разів відправляє клієнтові повідомлення `Hello!`,
та створює локального клієнта, який виводить все, що
отримує.

Результат роботи такої програми виглядає так:

```
b'Hello!\r\n'
b'Hello!\r\n'
b'Hello!\r\n'
b'Hello!\r\n'
b'Hello!\r\n'
b'Hello!\r\n'
b'Hello!\r\n'
b'Hello!\r\n'
b'Hello!\r\n'
b'Hello!\r\n'
```

Тепер, якщо дещо змінити програму...

```python
for i in range(10):
    new_client.send(b"Hello!")
    new_client.send(b"World!")
    print(client_socket.recv(4096))
```

...результат роботи стає непередбачуваним:

```
b'Hello!World!'
b'Hello!World!'
b'Hello!World!'
b'Hello!World!'
b'Hello!World!'
b'Hello!World!'
b'Hello!World!'
b'Hello!World!'
b'Hello!'
b'World!'
```

Більшість разів виклик `recv()` повертав
повідомлення, надіслані двома окремими викликами
функції `send()`, і лише в останній раз одному
виклику `send()` відповідав один виклик `recv()`.

У дуже навантажених системах така поведінка помітна
одразу, тому що вона неочікувана, а отже призводить
до помилок та збоїв. Найгірші наслідки чекають менш
навантажені системи, в яких така неочікувана
поведінка протоколу виявлятиме себе достатньо рідко,
щоб її можна було відловити, але достатньо часто,
щоб викликати головний біль у розробників та
користувачів.

### Реалізація повідомленнєвого протоколу
