##### Лабораторна робота 2
## Повідомленнєво-орієнтований протокол

### Зміст
* [Вступ](#вступ)
* [Оманлива поведінка функцій `send` та `recv`](#оманлива-поведінка-функцій-send-та-recv)
* [Реалізація повідомленнєвого протоколу](#реалізація-повідомленнєвого-протоколу)
  * [Розбиття потоку за допомогою роздільних символів](#розбиття-потоку-за-допомогою-роздільних-символів)
  * [Фіксований розмір повідомлення](#фіксований-розмір-повідомлення)
  * [Префіксування розміру повідомлення](#префіксування-розміру-повідомлення)
* [Індивідуальні завдання](#індивідуальні-завдання)

### Вступ

У попередній лабораторній роботі було зазначено, що
TCP -- це протокол *потокової* передачі даних.
Незважаючи на те, що цей протокол розбиває потік на
окремі пакети, ці пакети не можна розцінювати як
окремі повідомлення. Це є наслідком того факту, що
сторона-відправник може розбивати вихідний потік
даних як заманеться.

### Оманлива поведінка функцій `send` та `recv`

При роботі з TCP дуже легко зробити припущення про
те, що один виклик відправником функції `send`
відповідає одному виклику приймачем функції `recv`.
Справді, якщо відправник надсилатиме повідомлення
кожну секунду, то результат буде очевидним.

```python
from socket import socket
from time import sleep


server_socket = socket()
host = "localhost"
port = 1898
server_socket.bind((host, port))
server_socket.listen(5)

client_socket = socket()
client_socket.connect((host, port))


new_client, address = server_socket.accept()

for i in range(10):
    new_client.send(b"Hello!\r\n")
    sleep(1)
    print(client_socket.recv(4096))

new_client.close()
server_socket.close()
```

Ця програма створює локальний сервер, який десять
разів відправляє клієнтові повідомлення `Hello!`,
та створює локального клієнта, який виводить все, що
отримує.

Результат роботи такої програми виглядає так:

```
b'Hello!\r\n'
b'Hello!\r\n'
b'Hello!\r\n'
b'Hello!\r\n'
b'Hello!\r\n'
b'Hello!\r\n'
b'Hello!\r\n'
b'Hello!\r\n'
b'Hello!\r\n'
b'Hello!\r\n'
```

Тепер, якщо дещо змінити програму...

```python
for i in range(10):
    new_client.send(b"Hello!")
    new_client.send(b"World!")
    print(client_socket.recv(4096))
```

...результат роботи стає непередбачуваним:

```
b'Hello!World!'
b'Hello!World!'
b'Hello!World!'
b'Hello!World!'
b'Hello!World!'
b'Hello!World!'
b'Hello!World!'
b'Hello!World!'
b'Hello!'
b'World!'
```

Більшість разів виклик `recv()` повертав
повідомлення, надіслані двома окремими викликами
функції `send()`, і лише в останній раз одному
виклику `send()` відповідав один виклик `recv()`.

У дуже навантажених системах така поведінка помітна
одразу, тому що вона неочікувана, а отже призводить
до помилок та збоїв. Найгірші наслідки чекають менш
навантажені системи, в яких така неочікувана
поведінка протоколу виявлятиме себе достатньо рідко,
щоб її можна було відловити, але достатньо часто,
щоб викликати головний біль у розробників та
користувачів.

### Реалізація повідомленнєвого протоколу

Існує три загальновідомих способи розбиття потоку
на повідомлення:

1. За допомогою роздільних символів
2. Встановлення фіксованого розміру повідомлення
3. Префіксування розміру повідомлення

#### Розбиття потоку за допомогою роздільних символів

Оберемо за роздільний символ крапку (`.`).

| Клієнт надсилає | Сервер отримує |
|-----------------|----------------|
| `Hello.`        | `Hello`        |
| `Hello.Bye.`    | `Hello`        |
|                 | `Bye`          |
| `Hello.`        | `Hello`        |
| `One`           |                |
| `.`             | `One`          |
| `T`             |                |
| `w`             |                |
| `o`             |                |
| `.`             | `Two`          |
| `Two.One.One.`  | `Two`          |
|                 | `One`          |
|                 | `One`          |

Зауважте, що сервер може отримувати частини
повідомлення в різних пакетах. Таким чином робота
нашої програми не залежить від того, яким чином
протокол TCP розбиває потік байтів на пакети.


#### Фіксований розмір повідомлення

Оберемо розмір повідомлення 8 байтів.

| Клієнт надсилає | Сервер отримує |
|-----------------|----------------|
| `Hello---`      | `Hello---`     |
| `Bye`           |                |
| `-----`         | `Bye-----`     |
| `1234`          |                |
| `56`            |                |
| `7`             |                |
| `8`             | `12345678`     |

Такий протокол легко реалізовувати на низькорівневих
мовах програмування, але має недолік -- коли
потрібно надіслати кототке повідомлення,
доводиться все одно надсилати повідомлення довжиною
у 8 байтів. А коли необхідно надіслати повідомлення,
що довше за максимальний розмір, то клієнт та сервер
повинні домовитись, як розбивати довгі повідомлення
на короткі.

Такий протокол варто використовувати тільки тоді,
коли неможливо реалізувати кращий.

#### Префіксування розміру повідомлення

В такому протоколі перші декілька байтів відводяться
на довжину повідомлення.

Нехай ASCII символ першого байту позначатиме довжину
повідомлення:

| Клієнт надсилає |    Сервер отримує    |
|-----------------|----------------------|
| `5Hello`        | `Hello`              |
| `3Bye`          | `Bye`                |
| `9Hello,`       |                      |
| `bye`           | `Hello,bye`          |
| `0`             | порожнє повідомлення |

Зауважте:
1. Клієнт може надсилати повідомлення довільної
довжини
2. Клієнт може надіслати пусте повідомлення
3. Максимальний розмір повідомлення -- 9 байтів

В справжніх протоколах для позначення довжини
краще використовувати не ASCII символи а значення
байтів. При такому підході одного байту вистачає
для позначення довжини повідомлення від 0 до 255
символів.

Приклад функції, що реалізовує цей протокол:

```python
def recv_message(client_socket: socket):
    message_size = int(client_socket.recv(1))

    buffer = b''
    while len(buffer) < message_size:
        buffer += client_socket.recv(message_size - len(buffer))

    return buffer
```


### Індивідуальні завдання
