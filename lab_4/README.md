##### Лабораторна робота 4
## Примітивний TCP сервер-сховище

### Зміст
* [Вступ](#вступ)
* [Протокол збереження та отримання інформації](#протокол-збереження-та-отримання-інформації)
* [Абстрактний клас `Storage`](#абстрактний-клас-storage)
* [Абстрактний клас `MessageSocket`](#абстрактний-клас-messagesocket)
* [Реалізація протоколу збереження-відтворення](#реалізація-протоколу-збереження-відтворення)
* [Індивідуальні завдання](#індивідуальні-завдання)


### Вступ

Для закріплення вивченого матеріалу ця лабораторна
робота присвячена розробці простого TCP сервера,
який дозволяє зберігати та отримувати інформацію
у вигляді ключ-значення.

### Протокол збереження та отримання інформації

Перед початком розробки сервера необхідно
домовитись, якими командами це можна буде робити.

Нижче наведено один з можливих варіантів протоколу
спілкування з простим сервером-сховищем:

| Назва команди     | Вигляд команди       | Приклад використання   |
|-------------------|----------------------|------------------------|
| Зберегти значення | `s<ключ>:<значення>` | `sAGE:25`              |
| Отримати значення | `r<ключ>`            | `rAGE`                 |
| Завершити роботу  | `x`                  | `x`                    |

Цього протоколу повинні дотримуватись як сервер,
так і клієнт.

### Абстрактний клас `Storage`

Оскільки основною задачею нашого сервера є збереження
інформації, доцільно створити абстрактний клас, який
має лише два методи:

* `store(key, value)` -- зберегти значення `value`,
прив'язавши його до ключа `key`
* `retrieve(key)` -- отримати попередньо записане
значення за ключем `key`

Реалізація абстрактного класу `Storage` виглядає так:

```python
class Storage:

    def store(self, key, value):
        raise NotImplementedError

    def retrieve(self, key):
        raise NotImplementedError
```

Тепер, якщо ми захочемо, щоб сервер зберігав дані
у файлі, базі даних або у об'єкті `dict`, нам лише
необхідно успадкувати відповідний клас (`SQLStorage`,
`FileStorage`, `DictStorage`) та реалізувати для
нього методи `store` та `retrieve`. Тоді екземпляр
будь-якого такого класу можна передати серверу,
хоча сервер знає лише про абстрактний `Storage`.

Наприклад, ось так виглядає реалізація класу
`DictStorage`, який зберігає дані у об'єкті класу
`dict`, що вбудований в Пайтон:

```python
class DictStorage(Storage):

    def __init__(self):
        self.dict = dict()

    def store(self, key, value):
        self.dict[key] = value

    def retrieve(self, key):
        return self.dict[key]
```

Тож, якщо ваш сервер сервер в майбутньому повинен
зберігати дані в базі даних `MySQL`, ви можете на
етапі розробки користуватись класом `DictStorage`,
а потім реалізувати клас `MySQLStorage`.

### Абстрактний клас `MessageSocket`

Так само, як з класом `Storage`, для обрання способу
розбиття TCP потоку доцільно використати абстрактний
клас.

```python
class MessageSocket:

    def __init__(self, client_socket: socket):
        self.socket: socket = client_socket
        self.closed: bool = False

    def recv_message(self) -> bytes:
        raise NotImplementedError

    def send_message(self, message: bytes):
        raise NotImplementedError

    def close(self):
        raise NotImplementedError
```

У файлі `message_socket.py` наведені реалізації
класів `DelimitedMessageSocket` (розбиває потік за
роздільним символом) та `PrefixedMessageSocket`
(розбиває потік згідно довжині, зазначеній в
першому байті повідомлення).

### Реалізація протоколу збереження-відтворення

У цьому розділі ми розглянемо реалізацію
протоколу збереження-відтворення.

Функція-обробник клієнта працює вже з
`MessageSocket`, який ховає всередині звичайний
`socket`.

Почнемо з першої команди "Зберегти значення" --
спершу йде символ `s`, потім ключ та значення,
розділені двокрапкою:

```python
def handle_connection(self, client: MessageSocket):
    while not client.closed:
        message: bytes = client.recv_message()

        if message.startswith(b's'):
            key, value = message[1:].split(b':')
            self.storage.store(key, value)
    ...
```

Зауважте, що функція `handle_connection` обробляє
вхідні повідомлення у циклі -- отже клієнт може
залишатися на зв'язку та надсилати декілька
повідомлень протягом одного з'єднання.

Друга команда "Отримати значення" -- починається
з символу `r`, далі йде значення ключа. Клієнтові
повертається значення, закріплене за ключем:

```python
   ...
        elif message.startswith(b'r'):
            key = message[1:]
            value = self.storage.retrieve(key)
            client.send_message(value)
   ...
```

Третя команда "Завершити роботу" -- найпростіша.
Коли повідомлення починається з символу `x`,
з'єднання з клієнтом розривається:

```python
   ...
        elif message.startswith(b'x'):
            client.close()
            break
   ...
```

Ключове слово `break` змушує програму вийти з циклу,
і обробка з'єднання закінчується.

### Індивідуальні завдання
