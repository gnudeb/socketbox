##### Лабораторна робота 1
## Простий сервер на базі TCP

### Зміст
* [Вступ](#вступ)
* [Сокети](#сокети)
* [Типи сокетів](#типи-сокетів)
  * [Клієнт-сокет](#клієнт-сокет)
  * [Сервер-сокет](#сервер-сокет)
* [Індивідуальні завдання](#індивідуальні-завдання)

### Вступ

TCP (Transmission Control Protocol) -- протокол
надійної передачі потокової інформації.

Для забезпечення надійності передачі, TCP розбиває
потік даних на пакети, кожен зі своїм унікальним
номером, та очікує від отримувача підтвердження,
що кожен пакет надійшов. Якщо через деякий час
відправник не отримує підтвердження про успішне
отримання будь-якого пакету, то цей пакет буде
надіслано знову.

Важливо зазначити, що протокол не забороняє
розбивати потік на будь-які пакети або відправляти
пакети в будь-якому порядку.

### Сокети

Для роботи з TCP використовуються так звані "сокети"
(socket). Грубою мовою, сокет -- це об'єкт, який
інкапсулює TCP з'єднання з іншим сокетом крізь
інтернет (або у локальній мережі).

В загальному випадку, для створення сокету необхідно
здійснити відповідний системний виклик.
У UNIX-подібних системах такий виклик має
назву (як не дивно) `socket()`.
Оскільки системні виклики -- це дуже низькорівневий
спосіб роботи з сокетами, то більшість сучасних мов
програмування роблять усю брудну роботу за нас та
дозволяють швидко та безболісно створювати сокети
у знайомому середовищі. Так, у Пайтоні є цілий
модуль `socket`, який створено саме для таких потреб.

Нижче наведено приклад створення TCP сокету.

```python
from socket import socket, AF_INET, SOCK_STREAM

# Створення сокету
s = socket(family=AF_INET, type=SOCK_STREAM)
```

Зауважте, що конструктор класу `socket` приймає
декілька параметрів, зокрема `family` та `type`,
які приймають значення за замовчуванням `AF_INET`
(вказує, що ми працюємо з родиною адрес `IPv4`)
та `SOCK_STREAM` (вказує, що нам потрібен саме*TCP*
сокет). Розробники модулю `socket` зробили
припущення, що більшість людей використовуватимуть
саме TCP сокет у `IPv4` мережах, тому в таких
випадках аргументи можна не вказувати.

Зважаючи на цю інформацію, вищезазначений блок
коду можна переписати так:

```python
from socket import socket

s = socket()
```

### Типи сокетів

Після створення сокету, потрібно обрати, у якому
режимі працюватиме сокет -- у режимі "сервера" або
у режимі "клієнта". Важливо розуміти різницю: у
режимі сервера сокет не відправляє та не отримує
інформацію, а лише чекає на вхідні з'єднання.
Коли сокет-сервер приймає вхідне з'єднання,
створюється новий сокет-клієнт, саме який і
використовується для спілкування.

#### Клієнт-сокет

Нижче наведено приклад створення сокету типу
"клієнт", що підключається (метод `connect`) до
хосту `google.com` через порт `80`, а після
підключення робить HTTP запит (метод `send`) та
виводить відповідь ( метод `recv`):

```python
from socket import socket

s = socket()
host = "google.com"
port = 80
s.connect((host, port))

s.send("GET / HTTP1.1\r\n\r\n")
print(s.recv(4096))
s.close()
```

Коли ви вводите в адресний рядок браузера запит
`http://google.com`, ваш браузер робить приблизно
таку ж послідовність дій, як на останньому сніпеті.

#### Сервер-сокет

Розглянемо сервер-сокети.

Кожен сервер-сокет має пов'язаний з ним TCP порт.
Наприклад, HTTP сервери зазвичай працюють на порті
`80`, поштові сервери -- на портах `25`, `109` або
`110`.

Створимо сервер-сокет, що чекатиме на вхідні
з'єднання на порті `1898`:

```python
from socket import socket

s = socket()

host = "localhost"
port = 1898

s.bind((host, port))
s.listen(5)
```

Метод `bind` просить операційну систему зайняти
вказаний порт та дозволяти вхідні з'єднання в межах
локальної мережі (`localhost`). Після цього
виклику порт вже зайнятий, але під'єднатися ще не
можна. Зробити дозвіл на вхідні з'єднання потрібно
явно -- за допомогою метода `listen`. Цей метод
приймає один параметр -- кількість зовнішніх
з'єднань, які операційна система зберігатиме
у черзі, поки наш сервер їх не обробить.

Після успішного налаштування сокета можна приймати
вхідні з'єднання за допомогою метода `accept`:

```python
client_socket, address = s.accept()
```

Зауважте, що виклик методу `accept` повертає новий
щойно-створений сокет -- саме цей клієнт-сокет
використовуватиметься для спілкування крізь інтернет.

Нижче наведено приклад TCP серверу, що обробляє
з'єднання, надсилає клієнту рядок `"Hello, World!"`
та розриває з'єднання.

```python
from socket import socket

s = socket()

host = "localhost"
port = 1898

s.bind((host, port))
s.listen(5)

while True:
    client_socket, address = s.accept()
    client_socket.send(b"Hello, World!\r\n")
    client_socket.close()
```

Зауважте, що програма приймає з'єднання у вічному
циклі -- таким чином сервер може обслуговувати
багатьох клієнтів послідовно.

#### Індивідуальні завдання


